# 动态规划

## 1，什么是动态规划

涉及到有状态的转移的表示一种动态，如何转移的涉及到的规划

## 2，如何用动态规划去分析题目

比如：剑指 Offer 10- II. 青蛙跳台阶问题

2.1）分析题目，如何结题

因为是考虑跳台阶可能性的总和 f(n)，从最后一个台阶去分析，如果是最后剩一个，就是f(n-1) 的答案，然后如果是最后剩两节的跳法，就是f(n-2) 的答案，所以涉及总和就是 f(n) = f(n-1) + f(n-2)，然后从初始状态的计算，  n = 0 的时候，f(0) = 1，因为没有台阶的时候，就只有一种可能性，n = 1时，f(1) = 1, n = 2时，f(2) = 2，所以从和的结果来看，就是 1,1,2,3,5,8,13... 可以看到出来是一个斐波那契数列，所以先使用递归方法得到答案

```js
var  numWays = function(n) {
    if(n === 0 || n === 1) return 1
    if(n === 2) return 2
   	return numways(n -1) + numways(n -2)
}
```

但是提交结果超时

2.2）优化算法

考虑：涉及到递归的是不是可以转化为循环！！！

思考      f(5)

​    f(4)              f(3)

f(3)   f(2)       f(2)   f(1)

2.2.1）可以发现 f(5) 中涉及到 f(3) 的计算，但是在 f(4)又会涉及 f(3)的计算，重复计算了，所以是一个树形递归，这样的计算是很高的 ——  算法是可以通过记住一些东西，从而减少计算过程的。

所以思考，如何记住计算好的f(3)的值，其实可以从f(0), f(1), f(2)开始 —— 所以思考的初始状态（也是动态规划里面的初始状态）

2.2.2）然后找到 f(0), f(1), f(2)... 这个值是如何递增的，看到是类似斐波那契数列一样的，后边的一个值是前面两个值得和 ——得到递推的公式

2.2.3）从算法的角度思考，找到初始状态，然后存两个值 before 和 after，一个记住上一个数的值，一个计算下一个数，就是动态规划

```js
var  numWays = function(n) {
    // 动态规划 - 涉及初始状态
    if(n === 1 || n === 0) return 1
    let before = 1
    let after = 1
    let tmp 
    for(let i = 2; i <= n; i++) {
        // 动态规划 - 状态转移
        tmp = after
        after = before + after
        before = after
    }
    return after
}
```

